<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>anndict.dict &mdash; anndict 0.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=10f1778b"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            anndict
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Modules Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">anndict</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">anndict.dict</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for anndict.dict</h1><div class="highlight"><pre>
<span></span><span class="c1">#adata_dict functions</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">clone</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.validation</span> <span class="kn">import</span> <span class="n">check_random_state</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">LabelEncoder</span>
<span class="kn">import</span> <span class="nn">scanpy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">import</span> <span class="nn">anndata</span> <span class="k">as</span> <span class="nn">ad</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">HTML</span><span class="p">,</span> <span class="n">display</span>

<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">gaussian_kde</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linear_sum_assignment</span>

<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>
<span class="kn">import</span> <span class="nn">harmonypy</span> <span class="k">as</span> <span class="nn">hm</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span><span class="p">,</span> <span class="n">ThreadPoolExecutor</span><span class="p">,</span> <span class="n">as_completed</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">.metadata_summary</span> <span class="kn">import</span> <span class="n">summarize_metadata</span><span class="p">,</span> <span class="n">display_html_summary</span>
<span class="kn">from</span> <span class="nn">.stablelabel</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_slurm_cores</span><span class="p">,</span>
    <span class="n">pca_density_filter</span><span class="p">,</span>
    <span class="n">pca_density_wrapper</span><span class="p">,</span>
    <span class="n">pca_density_adata_dict</span><span class="p">,</span>
    <span class="n">stable_label</span><span class="p">,</span>
    <span class="n">stable_label_adata</span><span class="p">,</span>
    <span class="n">update_adata_labels_with_results</span><span class="p">,</span>
    <span class="n">plot_training_history</span><span class="p">,</span>
    <span class="n">plot_changes</span><span class="p">,</span>
    <span class="n">plot_confusion_matrix_from_adata</span><span class="p">,</span>
    <span class="n">plot_confusion_matrix</span><span class="p">,</span>
    <span class="n">plot_sankey</span><span class="p">,</span>
    <span class="n">save_sankey</span><span class="p">,</span>
    <span class="n">plot_grouped_average</span><span class="p">,</span>
    <span class="n">harmony_label_transfer</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">normalize_string</span><span class="p">,</span> <span class="n">normalize_label</span><span class="p">,</span> <span class="n">make_names</span><span class="p">,</span> <span class="n">add_label_to_adata</span><span class="p">,</span> <span class="n">convert_obs_col_to_category</span><span class="p">,</span> <span class="n">create_color_map</span>
<span class="kn">from</span> <span class="nn">.ai</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">attempt_ai_integration</span><span class="p">,</span> 
    <span class="n">generate_file_key</span><span class="p">,</span> 
    <span class="n">map_cell_type_labels_to_simplified_set</span><span class="p">,</span> 
    <span class="n">map_gene_labels_to_simplified_set</span><span class="p">,</span> 
    <span class="n">ai_biological_process</span><span class="p">,</span> 
    <span class="n">ai_cell_type</span><span class="p">,</span>
    <span class="n">ai_cell_types_by_comparison</span><span class="p">,</span>
    <span class="n">ai_compare_cell_types_binary</span><span class="p">,</span>
    <span class="n">ai_compare_cell_types_categorical</span><span class="p">,</span>
    <span class="n">ai_resolution_interpretation</span><span class="p">,</span>
    <span class="n">determine_sign_of_resolution_change</span>
<span class="p">)</span>


<div class="viewcode-block" id="AdataDict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.AdataDict">[docs]</a>
<span class="k">class</span> <span class="nc">AdataDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    AdataDict is a dictionary-like container where values are AnnData objects.</span>
<span class="sd">    </span>
<span class="sd">    This class provides two main functionalities:</span>
<span class="sd">    1. It behaves like an AnnData object by passing each method through to each AnnData in the dictionary. For example, adata_dict.obs.group_by(&quot;column&quot;) will apply the group_by method on the obs attribute of each AnnData object in the dictionary.</span>
<span class="sd">    2. It has a method fapply(func, kwargs) that applies a given function func with arguments kwargs to each AnnData object in the dictionary.</span>
<span class="sd">    </span>
<span class="sd">    Methods:</span>
<span class="sd">    __getattr__(attr) Dynamically creates methods that apply the corresponding method of AnnData objects in the dictionary.</span>
<span class="sd">        </span>
<span class="sd">    fapply(func, kwargs) Applies the provided function func with additional arguments kwargs to each AnnData object in the dictionary.</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">    Inherits attributes from the built-in dict class.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">results</span>
        <span class="k">return</span> <span class="n">method</span>
    
<div class="viewcode-block" id="AdataDict.fapply">
<a class="viewcode-back" href="../../modules.html#anndict.dict.AdataDict.fapply">[docs]</a>
    <span class="k">def</span> <span class="nf">fapply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>
</div>



<div class="viewcode-block" id="apply_func">
<a class="viewcode-back" href="../../modules.html#anndict.dict.apply_func">[docs]</a>
<span class="k">def</span> <span class="nf">apply_func</span><span class="p">(</span><span class="n">adt_key</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">accepts_key</span><span class="p">,</span> <span class="n">max_retries</span><span class="p">,</span> <span class="o">**</span><span class="n">func_args</span><span class="p">):</span>
    <span class="n">attempts</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">while</span> <span class="n">attempts</span> <span class="o">&lt;</span> <span class="n">max_retries</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">accepts_key</span><span class="p">:</span>
                <span class="n">func</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">adt_key</span><span class="o">=</span><span class="n">adt_key</span><span class="p">,</span> <span class="o">**</span><span class="n">func_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="o">**</span><span class="n">func_args</span><span class="p">)</span>
            <span class="k">return</span>  <span class="c1"># Success, exit the function</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">attempts</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing </span><span class="si">{</span><span class="n">adt_key</span><span class="si">}</span><span class="s2"> on attempt </span><span class="si">{</span><span class="n">attempts</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attempts</span> <span class="o">&gt;=</span> <span class="n">max_retries</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to process </span><span class="si">{</span><span class="n">adt_key</span><span class="si">}</span><span class="s2"> after </span><span class="si">{</span><span class="n">max_retries</span><span class="si">}</span><span class="s2"> attempts.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="adata_dict_fapply">
<a class="viewcode-back" href="../../modules.html#anndict.dict.adata_dict_fapply">[docs]</a>
<span class="k">def</span> <span class="nf">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">use_multithreading</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_retries</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_dicts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a given function to each AnnData object in the adata_dict, with error handling,</span>
<span class="sd">    retry mechanism, and the option to use either threading or sequential execution.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict: Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - func: Function to apply to each AnnData object in the dictionary.</span>
<span class="sd">    - use_multithreading: If True, use ThreadPoolExecutor; if False, execute sequentially.</span>
<span class="sd">    - num_workers: Number of worker threads to use (default: number of CPUs available).</span>
<span class="sd">    - max_retries: Maximum number of retries for a failed task.</span>
<span class="sd">    - kwargs_dicts: Additional keyword arguments to pass to the function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None: The function modifies the AnnData objects in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">accepts_key</span> <span class="o">=</span> <span class="s1">&#39;adt_key&#39;</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span>

    <span class="k">def</span> <span class="nf">get_arg_value</span><span class="p">(</span><span class="n">arg_value</span><span class="p">,</span> <span class="n">adt_key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg_value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">adt_key</span> <span class="ow">in</span> <span class="n">arg_value</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arg_value</span><span class="p">[</span><span class="n">adt_key</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">adata_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">arg_value</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">return</span> <span class="n">arg_value</span>  <span class="c1"># Use the entire dictionary if it doesn&#39;t contain all adata_dict keys</span>
        <span class="k">return</span> <span class="n">arg_value</span>  <span class="c1"># Use the value as is if it&#39;s not a dictionary or doesn&#39;t contain all adata_dict keys</span>

    <span class="k">if</span> <span class="n">use_multithreading</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="n">futures</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                    <span class="n">apply_func</span><span class="p">,</span> <span class="n">adt_key</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">accepts_key</span><span class="p">,</span> <span class="n">max_retries</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span>
                        <span class="n">arg_name</span><span class="p">:</span> <span class="n">get_arg_value</span><span class="p">(</span><span class="n">arg_value</span><span class="p">,</span> <span class="n">adt_key</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">arg_value</span> <span class="ow">in</span> <span class="n">kwargs_dicts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="p">}</span>
                <span class="p">):</span> <span class="n">adt_key</span> <span class="k">for</span> <span class="n">adt_key</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">):</span>
                <span class="n">adt_key</span> <span class="o">=</span> <span class="n">futures</span><span class="p">[</span><span class="n">future</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>  <span class="c1"># Retrieve result to catch exceptions</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unhandled error processing </span><span class="si">{</span><span class="n">adt_key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">adt_key</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">apply_func</span><span class="p">(</span><span class="n">adt_key</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">accepts_key</span><span class="p">,</span> <span class="n">max_retries</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span>
                    <span class="n">arg_name</span><span class="p">:</span> <span class="n">get_arg_value</span><span class="p">(</span><span class="n">arg_value</span><span class="p">,</span> <span class="n">adt_key</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">arg_value</span> <span class="ow">in</span> <span class="n">kwargs_dicts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">})</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unhandled error processing </span><span class="si">{</span><span class="n">adt_key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="apply_func_return">
<a class="viewcode-back" href="../../modules.html#anndict.dict.apply_func_return">[docs]</a>
<span class="k">def</span> <span class="nf">apply_func_return</span><span class="p">(</span><span class="n">adt_key</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">accepts_key</span><span class="p">,</span> <span class="n">max_retries</span><span class="p">,</span> <span class="o">**</span><span class="n">func_args</span><span class="p">):</span>
    <span class="n">attempts</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">while</span> <span class="n">attempts</span> <span class="o">&lt;</span> <span class="n">max_retries</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">accepts_key</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">adt_key</span><span class="o">=</span><span class="n">adt_key</span><span class="p">,</span> <span class="o">**</span><span class="n">func_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="o">**</span><span class="n">func_args</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">attempts</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing </span><span class="si">{</span><span class="n">adt_key</span><span class="si">}</span><span class="s2"> on attempt </span><span class="si">{</span><span class="n">attempts</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attempts</span> <span class="o">&gt;=</span> <span class="n">max_retries</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to process </span><span class="si">{</span><span class="n">adt_key</span><span class="si">}</span><span class="s2"> after </span><span class="si">{</span><span class="n">max_retries</span><span class="si">}</span><span class="s2"> attempts.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>  <span class="c1"># Optionally, return None or raise an error</span></div>



<div class="viewcode-block" id="adata_dict_fapply_return">
<a class="viewcode-back" href="../../modules.html#anndict.dict.adata_dict_fapply_return">[docs]</a>
<span class="k">def</span> <span class="nf">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">use_multithreading</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_retries</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_dicts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a given function to each AnnData object in the adata_dict, with error handling,</span>
<span class="sd">    retry mechanism, and the option to use either threading or sequential execution. Returns</span>
<span class="sd">    a dictionary with the results of the function applied to each AnnData object.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict: Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - func: Function to apply to each AnnData object in the dictionary.</span>
<span class="sd">    - use_multithreading: If True, use ThreadPoolExecutor; if False, execute sequentially.</span>
<span class="sd">    - num_workers: Number of worker threads to use (default: number of CPUs available).</span>
<span class="sd">    - max_retries: Maximum number of retries for a failed task.</span>
<span class="sd">    - kwargs_dicts: Additional keyword arguments to pass to the function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - dict: A dictionary with the same keys as adata_dict, containing the results of the function applied to each AnnData object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">accepts_key</span> <span class="o">=</span> <span class="s1">&#39;adt_key&#39;</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">get_arg_value</span><span class="p">(</span><span class="n">arg_value</span><span class="p">,</span> <span class="n">adt_key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg_value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">adt_key</span> <span class="ow">in</span> <span class="n">arg_value</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arg_value</span><span class="p">[</span><span class="n">adt_key</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">adata_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">arg_value</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">return</span> <span class="n">arg_value</span>  <span class="c1"># Use the entire dictionary if it doesn&#39;t contain all adata_dict keys</span>
        <span class="k">return</span> <span class="n">arg_value</span>  <span class="c1"># Use the value as is if it&#39;s not a dictionary or doesn&#39;t contain all adata_dict keys</span>

    <span class="k">if</span> <span class="n">use_multithreading</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="n">futures</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                    <span class="n">apply_func_return</span><span class="p">,</span> <span class="n">adt_key</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">accepts_key</span><span class="p">,</span> <span class="n">max_retries</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span>
                        <span class="n">arg_name</span><span class="p">:</span> <span class="n">get_arg_value</span><span class="p">(</span><span class="n">arg_value</span><span class="p">,</span> <span class="n">adt_key</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">arg_value</span> <span class="ow">in</span> <span class="n">kwargs_dicts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="p">}</span>
                <span class="p">):</span> <span class="n">adt_key</span> <span class="k">for</span> <span class="n">adt_key</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">):</span>
                <span class="n">adt_key</span> <span class="o">=</span> <span class="n">futures</span><span class="p">[</span><span class="n">future</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>  <span class="c1"># Retrieve result to catch exceptions</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">adt_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unhandled error processing </span><span class="si">{</span><span class="n">adt_key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">adt_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Optionally, return None or handle differently</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">adt_key</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">apply_func_return</span><span class="p">(</span><span class="n">adt_key</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">accepts_key</span><span class="p">,</span> <span class="n">max_retries</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span>
                    <span class="n">arg_name</span><span class="p">:</span> <span class="n">get_arg_value</span><span class="p">(</span><span class="n">arg_value</span><span class="p">,</span> <span class="n">adt_key</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">arg_value</span> <span class="ow">in</span> <span class="n">kwargs_dicts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">})</span>
                <span class="n">results</span><span class="p">[</span><span class="n">adt_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unhandled error processing </span><span class="si">{</span><span class="n">adt_key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">adt_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Optionally, return None or handle differently</span>

    <span class="k">return</span> <span class="n">results</span></div>



<span class="c1"># def adata_dict_fapply(adata_dict, func, **kwargs_dicts):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Applies a given function to each AnnData object in the adata_dict, with additional</span>
<span class="c1">#     values from other dictionaries or single values. The other dictionaries should</span>
<span class="c1">#     be passed as keyword arguments where the keys are the argument names that func takes.</span>

<span class="c1">#     Parameters:</span>
<span class="c1">#     - adata_dict: Dictionary of AnnData objects with keys as identifiers.</span>
<span class="c1">#     - func: Function to apply to each AnnData object in the dictionary.</span>
<span class="c1">#     - kwargs_dicts: Additional keyword arguments to pass to the function, where each argument can be a dictionary with keys matching the adata_dict or a single value.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#     - None: The function modifies the AnnData objects in place.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     import inspect</span>
<span class="c1">#     sig = inspect.signature(func)</span>
<span class="c1">#     accepts_key = &#39;adt_key&#39; in sig.parameters</span>

<span class="c1">#     for adt_key, adata in adata_dict.items():</span>
<span class="c1">#         func_args = {}</span>
<span class="c1">#         for arg_name, arg_value in kwargs_dicts.items():</span>
<span class="c1">#             if isinstance(arg_value, dict):</span>
<span class="c1">#                 if adt_key in arg_value:</span>
<span class="c1">#                     func_args[arg_name] = arg_value[adt_key]</span>
<span class="c1">#             else:</span>
<span class="c1">#                 func_args[arg_name] = arg_value</span>
        
<span class="c1">#         if accepts_key:</span>
<span class="c1">#             func(adata, adt_key=adt_key, **func_args)</span>
<span class="c1">#         else:</span>
<span class="c1">#             func(adata, **func_args)</span>


<span class="c1"># def adata_dict_fapply_return(adata_dict, func, **kwargs_dicts):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Applies a given function to each AnnData object in the adata_dict, with additional</span>
<span class="c1">#     values from other dictionaries or single values. The other dictionaries should</span>
<span class="c1">#     be passed as keyword arguments where the keys are the argument names that func takes.</span>

<span class="c1">#     Parameters:</span>
<span class="c1">#     - adata_dict: Dictionary of AnnData objects with keys as identifiers.</span>
<span class="c1">#     - func: Function to apply to each AnnData object in the dictionary.</span>
<span class="c1">#     - kwargs_dicts: Additional keyword arguments to pass to the function, where each argument can be a dictionary with keys matching the adata_dict or a single value.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#     - dict: A dictionary with the same keys as adata_dict, containing the results of the function applied to each AnnData object.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     import inspect</span>
<span class="c1">#     sig = inspect.signature(func)</span>
<span class="c1">#     accepts_key = &#39;adt_key&#39; in sig.parameters</span>

<span class="c1">#     results = {}</span>
<span class="c1">#     for adt_key, adata in adata_dict.items():</span>
<span class="c1">#         func_args = {}</span>
<span class="c1">#         for arg_name, arg_value in kwargs_dicts.items():</span>
<span class="c1">#             if isinstance(arg_value, dict):</span>
<span class="c1">#                 if adt_key in arg_value:</span>
<span class="c1">#                     func_args[arg_name] = arg_value[adt_key]</span>
<span class="c1">#             else:</span>
<span class="c1">#                 func_args[arg_name] = arg_value</span>
        
<span class="c1">#         if accepts_key:</span>
<span class="c1">#             results[adt_key] = func(adata, adt_key=adt_key, **func_args)</span>
<span class="c1">#         else:</span>
<span class="c1">#             results[adt_key] = func(adata, **func_args)</span>
<span class="c1">#     return results</span>


<div class="viewcode-block" id="check_and_create_strata">
<a class="viewcode-back" href="../../modules.html#anndict.dict.check_and_create_strata">[docs]</a>
<span class="k">def</span> <span class="nf">check_and_create_strata</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">strata_keys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if the specified stratifying variables are present in the AnnData object,</span>
<span class="sd">    and creates a new column combining these variables if it does not already exist.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata : (AnnData) An AnnData object.</span>
<span class="sd">    strata_keys : (list of str) List of keys (column names) in adata.obs to be used for stratification.</span>

<span class="sd">    Returns:</span>
<span class="sd">    str: (str) The name of the newly created or verified existing combined strata column.</span>

<span class="sd">    Raises:</span>
<span class="sd">    ValueError: If one or more of the specified stratifying variables do not exist in adata.obs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if any of the strata_keys are not present in adata.obs</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">strata_keys</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;one or more of your stratifying variables does not exist in adata.obs&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create a new column that combines the values of existing strata_keys, if not already present</span>
    <span class="n">strata_key</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strata_keys</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">strata_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">strata_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">strata_keys</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#make sure it&#39;s categorical</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">strata_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">strata_key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">strata_key</span></div>



<div class="viewcode-block" id="read_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.read_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">read_adata_dict</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads .h5ad files from a list of paths and returns them in a dictionary.</span>
<span class="sd">    For each element in the provided list of paths, if the element is a directory,</span>
<span class="sd">    it reads all .h5ad files in that directory. If the element is an .h5ad file,</span>
<span class="sd">    it reads the file directly. The results are returned as a dictionary with</span>
<span class="sd">    keys generated by generate_file_key() or fallback to &quot;ad1&quot;, &quot;ad2&quot;, ... if</span>
<span class="sd">    generate_file_key() fails, or uses provided keys if given.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    paths (list): A list of paths to directories or .h5ad files.</span>
<span class="sd">    keys (list, optional): A list of strings to use as keys for the adata_dict. If provided, must be equal in length to the number of .h5ad files read.</span>

<span class="sd">    Returns:</span>
<span class="sd">    dict: A dictionary with keys as specified or generated, and values as AnnData objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">file_paths</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># First, collect all file paths</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.h5ad&quot;</span><span class="p">):</span>
                    <span class="n">file_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.h5ad&quot;</span><span class="p">):</span>
            <span class="n">file_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="c1"># Check if provided keys match the number of files</span>
    <span class="k">if</span> <span class="n">keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_paths</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of provided keys (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match the number of .h5ad files (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">file_paths</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="c1"># Now process the files</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">file_path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">file_paths</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">attempt_ai_integration</span><span class="p">(</span><span class="n">generate_file_key</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;ad</span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
        
        <span class="n">adata_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">adata_dict</span></div>


<div class="viewcode-block" id="build_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.build_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">build_adata_dict</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">strata_keys</span><span class="p">,</span> <span class="n">desired_strata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a dictionary of AnnData objects split by desired strata values.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata (AnnData): Annotated data matrix.</span>
<span class="sd">    strata_keys (list of str): List of column names in `adata.obs` to use for stratification.</span>
<span class="sd">    desired_strata (list or dict, optional): List of desired strata values or a dictionary where keys are strata keys and values are lists of desired strata values. If None (Default), all combinations of categories in adata.obs[strata_keys] will be used.</span>
<span class="sd">    Returns:</span>
<span class="sd">    dict: Dictionary where keys are strata values and values are corresponding AnnData subsets.</span>

<span class="sd">    Raises:</span>
<span class="sd">    ValueError: If `desired_strata` is neither a list nor a dictionary of lists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">desired_strata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Generate all combinations of categories in adata.obs[strata_keys]</span>
        <span class="n">all_categories</span> <span class="o">=</span> <span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">strata_keys</span><span class="p">]</span>
        <span class="n">all_combinations</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">all_categories</span><span class="p">)</span>
        <span class="n">desired_strata</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">comb</span><span class="p">))</span> <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">all_combinations</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">build_adata_dict_main</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">strata_keys</span><span class="p">,</span> <span class="n">desired_strata</span><span class="p">,</span> <span class="n">print_missing_strata</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">desired_strata</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># Directly use the list of strata</span>
        <span class="k">return</span> <span class="n">build_adata_dict_main</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">strata_keys</span><span class="p">,</span> <span class="n">desired_strata</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">desired_strata</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="c1"># Generate all combinations of desired strata values across strata_keys</span>
        <span class="n">all_combinations</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">desired_strata</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">strata_keys</span><span class="p">))</span>
        <span class="c1"># Convert tuples of combinations to a format suitable for strata_keys</span>
        <span class="n">combined_strata_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">comb</span><span class="p">))</span> <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">all_combinations</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">build_adata_dict_main</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">strata_keys</span><span class="p">,</span> <span class="n">combined_strata_list</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;desired_strata must be either a list or a dictionary of lists&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="build_adata_dict_main">
<a class="viewcode-back" href="../../modules.html#anndict.dict.build_adata_dict_main">[docs]</a>
<span class="k">def</span> <span class="nf">build_adata_dict_main</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">strata_keys</span><span class="p">,</span> <span class="n">desired_strata</span><span class="p">,</span> <span class="n">print_missing_strata</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main function to build a dictionary of AnnData objects based on desired strata values.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata (AnnData): Annotated data matrix.</span>
<span class="sd">    strata_keys (list of str): List of column names in `adata.obs` to use for stratification.</span>
<span class="sd">    desired_strata (list of str): List of desired strata values.</span>

<span class="sd">    Returns:</span>
<span class="sd">    dict: Dictionary where keys are strata values and values are corresponding AnnData subsets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check and create stratifying variable in adata</span>
    <span class="n">strata_key</span> <span class="o">=</span> <span class="n">check_and_create_strata</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">strata_keys</span><span class="p">)</span>
    <span class="c1"># Initialize the dictionary to store subsets</span>
    <span class="n">subsets_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Filter adata for each desired stratum and add to the dictionary</span>
    <span class="k">for</span> <span class="n">stratum</span> <span class="ow">in</span> <span class="n">desired_strata</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">stratum</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">strata_key</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">:</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">strata_key</span><span class="p">]</span> <span class="o">==</span> <span class="n">stratum</span><span class="p">]</span>
            <span class="n">subsets_dict</span><span class="p">[</span><span class="n">stratum</span><span class="p">]</span> <span class="o">=</span> <span class="n">subset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_missing_strata</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: &#39;</span><span class="si">{</span><span class="n">stratum</span><span class="si">}</span><span class="s2">&#39; is not a valid category in &#39;</span><span class="si">{</span><span class="n">strata_key</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AdataDict</span><span class="p">(</span><span class="n">subsets_dict</span><span class="p">)</span></div>



<div class="viewcode-block" id="subsplit_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.subsplit_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">subsplit_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">strata_keys</span><span class="p">,</span> <span class="n">desired_strata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split each value of an AnnData dictionary into further subsets based on additional desired strata.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict (dict): Dictionary where keys are strata values and values are AnnData objects.</span>
<span class="sd">    strata_keys (list of str): List of column names in `adata.obs` to use for further stratification.</span>
<span class="sd">    desired_strata (list or dict): List of desired strata values or a dictionary where keys are strata keys and values are lists of desired strata values.</span>

<span class="sd">    Returns:</span>
<span class="sd">    dict: Nested dictionary of AnnData objects split by the additional desired strata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#this function takes an adata_dict and splits each value of the dictionary (an anndata) into a dictionary of anndatas</span>
    <span class="c1">#Would be correct to call this function: build_adata_dict_from_adata_dict()</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">build_adata_dict</span><span class="p">,</span> <span class="n">strata_keys</span><span class="o">=</span><span class="n">strata_keys</span><span class="p">,</span> <span class="n">desired_strata</span><span class="o">=</span><span class="n">desired_strata</span><span class="p">)</span></div>



<div class="viewcode-block" id="concatenate_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.concatenate_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">concatenate_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenates all AnnData objects in adata_dict into a single AnnData object.</span>
<span class="sd">    If only a single AnnData object is present, returns it as is.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - kwargs: Additional keyword arguments for concatenation.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - AnnData: A single AnnData object or the original AnnData object if only one is provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;join&#39;</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;index_unique&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># Ensure original indices are kept</span>

    <span class="n">adatas</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">adata_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">adatas</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adatas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Return the single AnnData object as is</span>
    
    <span class="k">if</span> <span class="n">adatas</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">adatas</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;adata_dict is empty. No data available to concatenate.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="summarize_metadata_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.summarize_metadata_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">summarize_metadata_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate summary tables for each AnnData object in the dictionary using the summarize_metadata function.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - kwargs: Additional keyword arguments, including &#39;columns&#39; which specifies a list of columns from the metadata to summarize. Use &#39;*&#39; to specify joint frequencies of multiple columns.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - dict: A dictionary of summary dictionaries for each AnnData object in the adata_dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">summarize_metadata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="display_html_summary_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.display_html_summary_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">display_html_summary_adata_dict</span><span class="p">(</span><span class="n">summary_dict_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Display separate HTML tables for each metadata category in the summary dictionaries,</span>
<span class="sd">    arranging up to three tables in a row before starting a new line.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    - summary_dict_dict (dict): A dictionary of summary dictionaries for each AnnData object in the adata_dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">stratum</span><span class="p">,</span> <span class="n">summary_dict</span> <span class="ow">in</span> <span class="n">summary_dict_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Summary for </span><span class="si">{</span><span class="n">stratum</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
        <span class="n">display_html_summary</span><span class="p">(</span><span class="n">summary_dict</span><span class="p">)</span></div>


<div class="viewcode-block" id="set_var_index">
<a class="viewcode-back" href="../../modules.html#anndict.dict.set_var_index">[docs]</a>
<span class="k">def</span> <span class="nf">set_var_index</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the index of adata.var to the specified column for each AnnData object in adata_dict.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict (dict): A dictionary where keys are identifiers and values are AnnData objects.</span>
<span class="sd">    column (str): The column name to set as the index of adata.var.</span>

<span class="sd">    Returns:</span>
<span class="sd">    dict: A dictionary with the same structure as adata_dict, where the var attribute of each AnnData object has its index set to the specified column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">set_var_index_main</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">adata</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">set_var_index_main</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="n">column</span><span class="p">)</span></div>



<div class="viewcode-block" id="set_obs_index">
<a class="viewcode-back" href="../../modules.html#anndict.dict.set_obs_index">[docs]</a>
<span class="k">def</span> <span class="nf">set_obs_index</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the index of adata.obs to the specified column for each AnnData object in adata_dict.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict (dict): A dictionary where keys are identifiers and values are AnnData objects.</span>
<span class="sd">    column (str): The column name to set as the index of adata.obs.</span>

<span class="sd">    Returns:</span>
<span class="sd">    dict: A dictionary with the same structure as adata_dict, where the obs attribute of each AnnData object has its index set to the specified column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">set_obs_index_main</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">adata</span>

    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">set_obs_index_main</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="n">column</span><span class="p">)</span></div>


<div class="viewcode-block" id="remove_genes">
<a class="viewcode-back" href="../../modules.html#anndict.dict.remove_genes">[docs]</a>
<span class="k">def</span> <span class="nf">remove_genes</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">genes_to_remove</span><span class="p">,</span> <span class="n">adt_key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove specified genes from an AnnData object in-place.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    adata (anndata.AnnData): The AnnData object to modify.</span>
<span class="sd">    genes_to_remove (list): A list of gene names to remove.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the list of genes to remove that are actually in the dataset</span>
    <span class="n">genes_to_remove</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">genes_to_remove</span><span class="p">)</span>
    
    <span class="c1"># Remove the specified genes</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">_inplace_subset_var</span><span class="p">(</span><span class="o">~</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">genes_to_remove</span><span class="p">))</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">genes_to_remove</span><span class="p">)</span><span class="si">}</span><span class="s2"> genes from </span><span class="si">{</span><span class="n">adt_key</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="si">}</span><span class="s2"> genes remaining.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="remove_genes_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.remove_genes_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">remove_genes_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">genes_to_remove</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove specified genes from each AnnData object in adata_dict.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict : dict A dictionary where keys are identifiers and values are AnnData objects.</span>
<span class="sd">    genes_to_remove : list A list of gene names to remove from each AnnData object.</span>

<span class="sd">    Returns:</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">remove_genes</span><span class="p">,</span> <span class="n">genes_to_remove</span><span class="o">=</span><span class="n">genes_to_remove</span><span class="p">)</span></div>



<div class="viewcode-block" id="subsample_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.subsample_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">subsample_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subsamples each AnnData object in the dictionary using Scanpy&#39;s subsample function.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - kwargs: Additional keyword arguments to pass to the subsample function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None: The function modifies the input AnnData objects in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_obs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n_obs&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">fraction</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fraction&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_obs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fraction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fraction</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fraction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fraction</span>

    <span class="k">def</span> <span class="nf">subsample_adata</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n_obs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">&gt;</span> <span class="n">n_obs</span><span class="p">:</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">subsample</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">subsample_adata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="resample_adata">
<a class="viewcode-back" href="../../modules.html#anndict.dict.resample_adata">[docs]</a>
<span class="k">def</span> <span class="nf">resample_adata</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">strata_keys</span><span class="p">,</span> <span class="n">min_num_cells</span><span class="p">,</span> <span class="n">n_largest_groups</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample an AnnData object based on specified strata keys and drop strata with fewer than the minimum number of cells.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata (AnnData): Annotated data matrix.</span>
<span class="sd">    strata_keys (list of str): List of column names in adata.obs to use for stratification.</span>
<span class="sd">    min_num_cells (int): Minimum number of cells required to retain a stratum.</span>
<span class="sd">    kwargs: Additional keyword arguments to pass to the subsample function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    AnnData: Concatenated AnnData object after resampling and filtering.</span>

<span class="sd">    Raises:</span>
<span class="sd">    ValueError: If any of the specified strata_keys do not exist in adata.obs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Step 1: Create the strata key</span>
    <span class="n">strata_key</span> <span class="o">=</span> <span class="n">check_and_create_strata</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">strata_keys</span><span class="p">)</span>

    <span class="c1"># Step 2: Calculate the size of each category</span>
    <span class="n">category_counts</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">strata_key</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
    
    <span class="c1"># Step 3: Identify the top n largest categories or all categories if n is None</span>
    <span class="k">if</span> <span class="n">n_largest_groups</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">selected_categories</span> <span class="o">=</span> <span class="n">category_counts</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">selected_categories</span> <span class="o">=</span> <span class="n">category_counts</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="n">n_largest_groups</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    
    <span class="c1"># Step 4: Build adata_dict based on the strata key</span>
    <span class="n">strata_dict</span> <span class="o">=</span> <span class="n">build_adata_dict</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="p">[</span><span class="n">strata_key</span><span class="p">],</span> <span class="n">selected_categories</span><span class="p">)</span>
    
    <span class="c1"># Step 5: Subsample each AnnData object in the strata_dict</span>
    <span class="n">subsample_adata_dict</span><span class="p">(</span><span class="n">strata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="c1"># Step 6: Drop AnnData objects with fewer than min_num_cells</span>
    <span class="n">filtered_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">strata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">&gt;=</span> <span class="n">min_num_cells</span><span class="p">}</span>
    
    <span class="c1"># Step 7: Concatenate the filtered_dict back to a single AnnData object</span>
    <span class="c1">#setting index_unique=None avoids index modification</span>
    <span class="k">return</span> <span class="n">concatenate_adata_dict</span><span class="p">(</span><span class="n">filtered_dict</span><span class="p">,</span> <span class="n">index_unique</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>



<div class="viewcode-block" id="resample_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.resample_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">resample_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">strata_keys</span><span class="p">,</span> <span class="n">n_largest_groups</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_num_cells</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample each AnnData object in a dictionary based on specified strata keys and drop strata with fewer than the minimum number of cells.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict (dict): Dictionary where keys are strata values and values are AnnData objects.</span>
<span class="sd">    strata_keys (list of str): List of column names in adata.obs to use for stratification.</span>
<span class="sd">    min_num_cells (int, optional): Minimum number of cells required to retain a stratum. Default is 0.</span>
<span class="sd">    kwargs: Additional keyword arguments to pass to the resample function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    dict: Dictionary of resampled AnnData objects after filtering.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">resample_adata</span><span class="p">,</span> <span class="n">strata_keys</span><span class="o">=</span><span class="n">strata_keys</span><span class="p">,</span> <span class="n">n_largest_groups</span><span class="o">=</span><span class="n">n_largest_groups</span><span class="p">,</span> <span class="n">min_num_cells</span><span class="o">=</span><span class="n">min_num_cells</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="normalize_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.normalize_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalizes each AnnData object in the dictionary using Scanpy&#39;s normalize_total.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - kwargs: Additional keyword arguments to pass to the normalize_total function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None: The function modifies the input AnnData objects in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">normalize_total</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="log_transform_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.log_transform_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">log_transform_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Log-transforms each AnnData object in the dictionary using Scanpy&#39;s log1p.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - kwargs: Additional keyword arguments to pass to the log1p function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None: The function modifies the input AnnData objects in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">log1p</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="set_high_variance_genes_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.set_high_variance_genes_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">set_high_variance_genes_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies high-variance genes in each AnnData object in the dictionary.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - kwargs: Additional keyword arguments to pass to the highly_variable_genes function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None: The function modifies the input AnnData objects in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">highly_variable_genes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="rank_genes_groups_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.rank_genes_groups_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">rank_genes_groups_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies differentially expressed genes in each AnnData object in the dictionary.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - kwargs: Additional keyword arguments to pass to the rank_genes_groups function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None: The function modifies the input AnnData objects in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">rank_genes_groups</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="scale_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.scale_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">scale_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scales each AnnData object in the dictionary using Scanpy&#39;s scale function.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - kwargs: Additional keyword arguments to pass to the scale function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None: The function modifies the input AnnData objects in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="pca_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.pca_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">pca_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs PCA on each AnnData object in the dictionary using Scanpy&#39;s pca function.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - kwargs: Additional keyword arguments to pass to the pca function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None: The function modifies the input AnnData objects in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">pca</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="neighbors_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.neighbors_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">neighbors_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates neighborhood graph for each AnnData object in the dictionary using Scanpy&#39;s neighbors function.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - kwargs: Additional keyword arguments to pass to the sc.pp.neighbors function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None: The function modifies the input AnnData objects in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">neighbors</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="leiden_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.leiden_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">leiden_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs Leiden clustering for each AnnData object in the dictionary using Scanpy&#39;s leiden function.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): Dictionary of AnnData objects with keys as identifiers.</span>
<span class="sd">    - kwargs: Additional keyword arguments to pass to the sc.tl.leiden function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None: The function modifies the input AnnData objects in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">leiden</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="leiden_sub_cluster">
<a class="viewcode-back" href="../../modules.html#anndict.dict.leiden_sub_cluster">[docs]</a>
<span class="k">def</span> <span class="nf">leiden_sub_cluster</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Leiden clustering on subgroups of cells.</span>
<span class="sd">    This function applies Leiden clustering to subgroups of cells defined by the groupby parameter.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata : AnnData Annotated data matrix.</span>
<span class="sd">    groupby : str Column name in adata.obs for grouping cells before subclustering.</span>
<span class="sd">    kwargs : dict Additional keyword arguments to pass to the leiden_adata_dict function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    None, The function modifies the input AnnData object in-place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict</span> <span class="o">=</span> <span class="n">build_adata_dict</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">strata_keys</span><span class="o">=</span><span class="p">[</span><span class="n">groupby</span><span class="p">])</span>
    <span class="n">leiden_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">concatenate_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">index_unique</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="c1">#setting index_unique=None avoids index modification</span>
    <span class="k">return</span> <span class="n">adata</span></div>



<div class="viewcode-block" id="leiden_sub_cluster_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.leiden_sub_cluster_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">leiden_sub_cluster_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function applies the leiden_sub_cluster function to each AnnData object</span>
<span class="sd">    in the provided dictionary.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict : dict Dictionary of AnnData objects.</span>
<span class="sd">    groupby : str Column name in adata.obs for grouping cells before subclustering.</span>
<span class="sd">    kwargs : dict Additional keyword arguments to pass to the leiden_sub_cluster function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    None The function modifies the input AnnData objects in-place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">leiden_sub_cluster</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="n">groupby</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="calculate_umap_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.calculate_umap_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_umap_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates UMAP embeddings for each subset in the adata_dict.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): A dictionary with keys as strata and values as AnnData objects.</span>
<span class="sd">    - kwargs: Additional keyword arguments, including &#39;use_rep&#39; which specifies the key in .obsm where the representation matrix is stored.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - dict: A dictionary with the same keys as adata_dict, but values now include UMAP coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># def calculate_umap(adata, **kwargs):</span>
    <span class="c1">#     use_rep = kwargs.get(&#39;use_rep&#39;)</span>
    <span class="c1">#     if use_rep in adata.obsm:</span>
    <span class="c1">#         sc.pp.neighbors(adata, use_rep=use_rep)</span>
    <span class="c1">#         sc.tl.umap(adata)</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         print(f&quot;Representation &#39;{use_rep}&#39; not found in .obsm of adata.&quot;)</span>
    <span class="c1"># adata_dict_fapply(adata_dict, calculate_umap, **kwargs)</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">umap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">adata_dict</span></div>



<div class="viewcode-block" id="plot_umap_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.plot_umap_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">plot_umap_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots UMAP embeddings for each AnnData object in adata_dict, colored by a specified variable.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict (dict): A dictionary with keys as strata and values as AnnData objects.</span>
<span class="sd">    - kwargs: Additional keyword arguments, including &#39;color_by&#39; which specifies a variable by which to color the UMAP plots, typically a column in .obs.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None: The function creates plots for the AnnData objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">plot_umap</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">adt_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting UMAP for key: </span><span class="si">{</span><span class="n">adt_key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;X_umap&#39;</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">:</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">pl</span><span class="o">.</span><span class="n">umap</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;UMAP not computed for adata with key </span><span class="si">{</span><span class="n">adt_key</span><span class="si">}</span><span class="s2">. Please compute UMAP before plotting.&quot;</span><span class="p">)</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">plot_umap</span><span class="p">,</span> <span class="n">use_multithreading</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="write_h5ad_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.write_h5ad_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">write_h5ad_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">directory</span><span class="p">,</span> <span class="n">file_prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves each AnnData object from adata_dict into separate .h5ad files.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict: Dictionary of AnnData objects, with keys as identifiers.</span>
<span class="sd">    - directory: String, directory path where .h5ad files will be saved.</span>
<span class="sd">    - file_prefix: String, optional prefix for the filenames.</span>

<span class="sd">    Example:</span>
<span class="sd">    - If ``file_prefix`` is ``experiment1_``, files will be named ``experiment1_group1.h5ad`` for a key ``group1``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure the directory exists, create if it doesn&#39;t</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Iterate over the dictionary and save each AnnData object</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Construct the file path</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_prefix</span><span class="si">}{</span><span class="n">key</span><span class="si">}</span><span class="s2">.h5ad&quot;</span><span class="p">)</span>
        <span class="c1"># Save the AnnData object</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">adata</span><span class="p">)</span></div>



<div class="viewcode-block" id="stable_label_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.stable_label_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">stable_label_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">feature_key</span><span class="p">,</span> <span class="n">label_key</span><span class="p">,</span> <span class="n">classifier_class</span><span class="p">,</span> <span class="n">max_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">stability_threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">moving_average_length</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trains a classifier for each AnnData object in adata_dict.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict (dict): Dictionary with keys as identifiers and values as AnnData objects.</span>
<span class="sd">    feature_key (str): Key to access the features in adata.obsm.</span>
<span class="sd">    label_key (str): Key to access the labels in adata.obs.</span>
<span class="sd">    classifier: Classifier instance that implements fit and predict_proba methods.</span>
<span class="sd">    max_iterations, stability_threshold, moving_average_length, random_state: Additional parameters for training.</span>
<span class="sd">    kwargs: Additional keyword arguments to pass to the classifier constructor.</span>

<span class="sd">    Returns:</span>
<span class="sd">    results: Dict, keys are the identifiers from adata_dict and values are dictionaries containing the outputs from stable_label_adata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stable_label_results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">stratum</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Training classifier for </span><span class="si">{</span><span class="n">stratum</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#create a classifier for this stratum</span>
        <span class="n">classifier</span> <span class="o">=</span> <span class="n">classifier_class</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">trained_classifier</span><span class="p">,</span> <span class="n">history</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">final_labels</span><span class="p">,</span> <span class="n">label_encoder</span> <span class="o">=</span> <span class="n">stable_label_adata</span><span class="p">(</span>
            <span class="n">adata</span><span class="p">,</span> <span class="n">feature_key</span><span class="p">,</span> <span class="n">label_key</span><span class="p">,</span> <span class="n">classifier</span><span class="p">,</span> <span class="n">max_iterations</span><span class="p">,</span> <span class="n">stability_threshold</span><span class="p">,</span> <span class="n">moving_average_length</span><span class="p">,</span> <span class="n">random_state</span>
        <span class="p">)</span>

        <span class="n">stable_label_results</span><span class="p">[</span><span class="n">stratum</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;classifier&#39;</span><span class="p">:</span> <span class="n">trained_classifier</span><span class="p">,</span>
            <span class="s1">&#39;history&#39;</span><span class="p">:</span> <span class="n">history</span><span class="p">,</span>
            <span class="s1">&#39;iterations&#39;</span><span class="p">:</span> <span class="n">iterations</span><span class="p">,</span>
            <span class="s1">&#39;final_labels&#39;</span><span class="p">:</span> <span class="n">final_labels</span><span class="p">,</span>
            <span class="s1">&#39;label_encoder&#39;</span><span class="p">:</span> <span class="n">label_encoder</span><span class="p">,</span>
            <span class="s1">&#39;indices&#39;</span><span class="p">:</span> <span class="n">indices</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="n">stable_label_results</span></div>



<div class="viewcode-block" id="predict_labels_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.predict_labels_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">predict_labels_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">stable_label_results</span><span class="p">,</span> <span class="n">feature_key</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predicts labels for each AnnData object in adata_dict using the corresponding classifier from stable_label_results,</span>
<span class="sd">    and converts numeric predictions back to text labels.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict (dict): Dictionary with keys as identifiers and values as AnnData objects.</span>
<span class="sd">    stable_label_results (dict): Dictionary with keys as identifiers and values as dictionaries containing the trained classifier and other outputs from stable_label_adata.</span>
<span class="sd">    feature_key (str): Key to access the features in adata.obsm.</span>

<span class="sd">    Returns:</span>
<span class="sd">    predictions_dict (dict): Dictionary with keys as identifiers from adata_dict and values as predicted text labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">predictions_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">stratum</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">stratum</span> <span class="ow">in</span> <span class="n">stable_label_results</span><span class="p">:</span>
            <span class="n">classifier</span> <span class="o">=</span> <span class="n">stable_label_results</span><span class="p">[</span><span class="n">stratum</span><span class="p">][</span><span class="s1">&#39;classifier&#39;</span><span class="p">]</span>
            <span class="n">label_encoder</span> <span class="o">=</span> <span class="n">stable_label_results</span><span class="p">[</span><span class="n">stratum</span><span class="p">][</span><span class="s1">&#39;label_encoder&#39;</span><span class="p">]</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="n">feature_key</span><span class="p">]</span>

            <span class="c1"># Predict the numeric labels using the trained classifier</span>
            <span class="n">predicted_numeric_labels</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

            <span class="c1"># Check if predicted labels are within the range of the label encoder&#39;s classes</span>
            <span class="n">valid_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">label_encoder</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">label_encoder</span><span class="o">.</span><span class="n">classes_</span><span class="p">))</span>
            <span class="n">invalid_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">predicted_numeric_labels</span><span class="p">)</span> <span class="o">-</span> <span class="n">valid_labels</span>

            <span class="k">if</span> <span class="n">invalid_labels</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: Predicted labels </span><span class="si">{</span><span class="n">invalid_labels</span><span class="si">}</span><span class="s2"> are not in the label encoder&#39;s classes for </span><span class="si">{</span><span class="n">stratum</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Convert numeric predictions back to text labels</span>
            <span class="n">predicted_text_labels</span> <span class="o">=</span> <span class="n">label_encoder</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">predicted_numeric_labels</span><span class="p">)</span>
            
            <span class="c1"># Get the indices of the cells</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

            <span class="n">predictions_dict</span><span class="p">[</span><span class="n">stratum</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;indices&#39;</span><span class="p">:</span> <span class="n">indices</span><span class="p">,</span>
                <span class="s1">&#39;predicted_labels&#39;</span><span class="p">:</span> <span class="n">predicted_text_labels</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No classifier found for </span><span class="si">{</span><span class="n">stratum</span><span class="si">}</span><span class="s2">. Skipping prediction.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">predictions_dict</span></div>



<div class="viewcode-block" id="update_adata_labels_with_stable_label_results_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.update_adata_labels_with_stable_label_results_dict">[docs]</a>
<span class="k">def</span> <span class="nf">update_adata_labels_with_stable_label_results_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">stable_label_results_dict</span><span class="p">,</span> <span class="n">new_label_key</span><span class="o">=</span><span class="s1">&#39;stable_cell_type&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates each AnnData object in adata_dict with new labels from stable_label_results_dict.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict: Dictionary of AnnData objects to be updated.</span>
<span class="sd">    - stable_label_results_dict: Dictionary of dictionaries containing results, including indices and final_labels for each AnnData key.</span>
<span class="sd">    - new_label_key: Name of the new column in adata.obs where the labels will be stored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">update_adata_dict_with_label_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">stable_label_results_dict</span><span class="p">,</span> <span class="n">new_label_key</span><span class="o">=</span><span class="n">new_label_key</span><span class="p">,</span> <span class="n">label_key</span><span class="o">=</span><span class="s1">&#39;final_labels&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="update_adata_labels_with_predictions_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.update_adata_labels_with_predictions_dict">[docs]</a>
<span class="k">def</span> <span class="nf">update_adata_labels_with_predictions_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">predictions_dict</span><span class="p">,</span> <span class="n">new_label_key</span><span class="o">=</span><span class="s1">&#39;predicted_cell_type&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates each AnnData object in adata_dict with new labels from predictions_dict.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict: Dictionary of AnnData objects to be updated.</span>
<span class="sd">    - predictions_dict: Dictionary of predicted labels for each AnnData key.</span>
<span class="sd">    - new_label_key: Name of the new column in adata.obs where the labels will be stored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">update_adata_dict_with_label_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">predictions_dict</span><span class="p">,</span> <span class="n">new_label_key</span><span class="o">=</span><span class="n">new_label_key</span><span class="p">,</span> <span class="n">label_key</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="update_adata_dict_with_label_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.update_adata_dict_with_label_dict">[docs]</a>
<span class="k">def</span> <span class="nf">update_adata_dict_with_label_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">results_dict</span><span class="p">,</span> <span class="n">new_label_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label_key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function to update each AnnData object in adata_dict with new labels from results_dict.</span>
<span class="sd">    Accepts either &#39;final_labels&#39; or &#39;predicted_labels&#39; as the label key.</span>
<span class="sd">    results_dict can be either 1) stable_label_results: the object returned by stable_label_adata_dict()</span>
<span class="sd">    or 2) predictions_dict: the object returned by predict_labels_adata_dict</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata_dict: Dictionary of AnnData objects to be updated.</span>
<span class="sd">    - results_dict: Dictionary containing results, including indices and labels for each AnnData key.</span>
<span class="sd">    - new_label_key: Name of the new column in adata.obs where the labels will be stored.</span>
<span class="sd">    - label_key: Key to access the labels in results_dict (either &#39;final_labels&#39; or &#39;predicted_labels&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">results_dict</span><span class="p">:</span>
            <span class="n">subset_results</span> <span class="o">=</span> <span class="n">results_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">subset_results</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">]</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">subset_results</span><span class="p">[</span><span class="n">label_key</span><span class="p">]</span>

            <span class="n">add_label_to_adata</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">new_label_key</span><span class="p">)</span></div>



<div class="viewcode-block" id="plot_changes_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.plot_changes_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">plot_changes_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">true_label_key</span><span class="p">,</span> <span class="n">predicted_label_key</span><span class="p">,</span> <span class="n">percentage</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies the plot_final_mismatches function to each AnnData object in adata_dict.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict (dict): Dictionary with keys as identifiers and values as AnnData objects.</span>
<span class="sd">    predicted_label_key (str): The key in obs for predicted labels.</span>
<span class="sd">    true_label_key (str): The key in obs for true labels.</span>
<span class="sd">    percentage (bool): If True, plot percentages, otherwise plot counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">stratum</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting changes for </span><span class="si">{</span><span class="n">stratum</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">plot_changes</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">true_label_key</span><span class="p">,</span> <span class="n">predicted_label_key</span><span class="p">,</span> <span class="n">percentage</span><span class="p">,</span> <span class="n">stratum</span><span class="p">)</span></div>



<div class="viewcode-block" id="plot_confusion_matrix_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.plot_confusion_matrix_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">plot_confusion_matrix_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">true_label_key</span><span class="p">,</span> <span class="n">predicted_label_key</span><span class="p">,</span>
                                     <span class="n">row_color_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col_color_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">diagonalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies the plot_confusion_matrix_from_adata function to each AnnData object in adata_dict.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict (dict): Dictionary with keys as identifiers and values as AnnData objects.</span>
<span class="sd">    true_label_key (str): The key in obs for true class labels.</span>
<span class="sd">    predicted_label_key (str): The key in obs for predicted class labels.</span>
<span class="sd">    title (str): Title of the plot, which will be prefixed with the stratum name.</span>
<span class="sd">    row_color_keys (list): Optional keys for row colors in adata.obs.</span>
<span class="sd">    col_color_keys (list): Optional keys for column colors in adata.obs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">stratum</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Customize title for each subset</span>
        <span class="n">subset_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Confusion Matrix for </span><span class="si">{</span><span class="n">stratum</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">plot_confusion_matrix_from_adata</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">true_label_key</span><span class="p">,</span> <span class="n">predicted_label_key</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">subset_title</span><span class="p">,</span>
                                         <span class="n">row_color_keys</span><span class="o">=</span><span class="n">row_color_keys</span><span class="p">,</span> <span class="n">col_color_keys</span><span class="o">=</span><span class="n">col_color_keys</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="n">diagonalize</span><span class="o">=</span><span class="n">diagonalize</span><span class="p">)</span></div>



<div class="viewcode-block" id="harmony_label_transfer_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.harmony_label_transfer_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">harmony_label_transfer_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">master_data</span><span class="p">,</span> <span class="n">master_subset_column</span><span class="o">=</span><span class="s1">&#39;tissue&#39;</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;cell_type&#39;</span><span class="p">):</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">harmony_label_transfer</span><span class="p">,</span> <span class="n">master_data</span><span class="o">=</span><span class="n">master_data</span><span class="p">,</span> <span class="n">master_subset_column</span><span class="o">=</span><span class="n">master_subset_column</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="n">label_column</span><span class="p">)</span></div>



<span class="c1">#AI integrations</span>
<div class="viewcode-block" id="ai_determine_leiden_resolution">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_determine_leiden_resolution">[docs]</a>
<span class="k">def</span> <span class="nf">ai_determine_leiden_resolution</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">initial_resolution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjusts the Leiden clustering resolution of an AnnData object based on AI feedback.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (AnnData): The annotated data matrix.</span>
<span class="sd">        initial_resolution (float): The initial resolution for Leiden clustering.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The final resolution value after adjustments based on AI interpretation.</span>

<span class="sd">    This function iteratively performs Leiden clustering on the AnnData object,</span>
<span class="sd">    generates a UMAP plot, and uses an AI model to interpret the plot and suggest</span>
<span class="sd">    whether to increase, decrease, or maintain the current resolution. The resolution</span>
<span class="sd">    is adjusted by ±0.1 based on the AI&#39;s suggestion until no further adjustment is needed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">resolution</span> <span class="o">=</span> <span class="n">initial_resolution</span>
    <span class="n">previous_sign_change</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">leiden</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">)</span>
        
        <span class="c1"># Plot UMAP colored by Leiden clusters</span>
        <span class="k">def</span> <span class="nf">plot_umap</span><span class="p">():</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">pl</span><span class="o">.</span><span class="n">umap</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;leiden&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Get AI interpretation</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">ai_resolution_interpretation</span><span class="p">(</span><span class="n">plot_umap</span><span class="p">)</span>
        
        <span class="c1"># Determine the sign of resolution change</span>
        <span class="n">sign_change</span> <span class="o">=</span> <span class="n">determine_sign_of_resolution_change</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
        
        <span class="c1"># Check if the resolution needs to be adjusted</span>
        <span class="k">if</span> <span class="n">sign_change</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">resolution</span>
        <span class="k">elif</span> <span class="n">previous_sign_change</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sign_change</span> <span class="o">!=</span> <span class="n">previous_sign_change</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">resolution</span> <span class="o">+</span> <span class="mf">0.15</span> <span class="o">*</span> <span class="n">sign_change</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">resolution</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">resolution</span> <span class="o">+</span> <span class="mf">0.15</span> <span class="o">*</span> <span class="n">sign_change</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="n">previous_sign_change</span> <span class="o">=</span> <span class="n">sign_change</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">resolution</span></div>



<div class="viewcode-block" id="ai_determine_leiden_resolution_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_determine_leiden_resolution_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">ai_determine_leiden_resolution_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">initial_resolution</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjusts Leiden clustering resolution for each AnnData object in a dictionary based on AI feedback.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata_dict (dict): Dictionary of AnnData objects.</span>
<span class="sd">        initial_resolution (float): Initial resolution for Leiden clustering (default is 1).</span>

<span class="sd">    Returns: dict: Dictionary with final resolution values after AI-based adjustments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">ai_determine_leiden_resolution</span><span class="p">,</span> <span class="n">max_retries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">initial_resolution</span><span class="o">=</span><span class="n">initial_resolution</span><span class="p">)</span></div>



<div class="viewcode-block" id="simplify_obs_column">
<a class="viewcode-back" href="../../modules.html#anndict.dict.simplify_obs_column">[docs]</a>
<span class="k">def</span> <span class="nf">simplify_obs_column</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">new_column_name</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplifies labels in the specified column of the AnnData object and stores the result</span>
<span class="sd">    in a new column using the map_cell_type_labels_to_simplified_set().</span>

<span class="sd">    Args:</span>
<span class="sd">    adata (AnnData): The AnnData object containing the data.</span>
<span class="sd">    column (str): The column in adata.obs containing the cell type labels to simplify.</span>
<span class="sd">    new_column_name (str): The name of the new column to store the simplified labels.</span>
<span class="sd">    simplification_level (str, optional): Defaults to &#39;&#39;. A qualitative description of how much you want the labels to be simplified. Could be anything, like  &#39;extremely&#39;, &#39;barely&#39;, or &#39;compartment-level&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the unique labels from the specified column</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="c1"># Get the mapping of original labels to simplified labels using the provided function</span>
    <span class="n">label_mapping</span> <span class="o">=</span> <span class="n">map_cell_type_labels_to_simplified_set</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="n">simplification_level</span><span class="p">)</span>

    <span class="c1"># Apply the mapping to create the new column in the AnnData object</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">label_mapping</span><span class="p">)</span>

    <span class="c1">#Convert annotation to categorical dtype</span>
    <span class="n">convert_obs_col_to_category</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">new_column_name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">label_mapping</span></div>



<div class="viewcode-block" id="simplify_obs_column_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.simplify_obs_column_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">simplify_obs_column_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">new_column_name</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies simplify_obs_column to each anndata in an anndict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">simplify_obs_column</span><span class="p">,</span> <span class="n">max_retries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="n">column</span><span class="p">,</span> <span class="n">new_column_name</span><span class="o">=</span><span class="n">new_column_name</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="n">simplification_level</span><span class="p">)</span></div>



<div class="viewcode-block" id="create_label_hierarchy">
<a class="viewcode-back" href="../../modules.html#anndict.dict.create_label_hierarchy">[docs]</a>
<span class="k">def</span> <span class="nf">create_label_hierarchy</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">simplification_levels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a hierarchy of simplified labels based on a given column in AnnData.</span>

<span class="sd">    This function generates multiple levels of simplified labels from an original</span>
<span class="sd">    column in the AnnData object. Each level of simplification is created using</span>
<span class="sd">    the specified simplification levels.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata : AnnData Annotated data matrix containing the column to be simplified.</span>
<span class="sd">    col : str Name of the column in adata.obs to be simplified.</span>
<span class="sd">    simplification_levels : list List of simplification levels to apply. Each level should be a value that can be used by the simplify_obs_column function.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    dict A dictionary mapping new column names to their corresponding simplified label mappings. The keys are the names of the new columns created for each simplification level, and the values are the mappings returned by simplify_obs_column for each level.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_col_name</span> <span class="o">=</span> <span class="n">col</span>
    <span class="n">simplified_mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">simplification_levels</span><span class="p">:</span>
        <span class="n">new_col_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_col_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">make_names</span><span class="p">([</span><span class="n">level</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">simplified_mapping</span><span class="p">[</span><span class="n">new_col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify_obs_column</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">new_col_name</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">new_col_name</span>
    <span class="k">return</span> <span class="n">simplified_mapping</span></div>



<div class="viewcode-block" id="create_label_hierarchy_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.create_label_hierarchy_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">create_label_hierarchy_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">simplification_levels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies create_label_hierarchy to each anndata in an anndict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">create_label_hierarchy</span><span class="p">,</span> <span class="n">max_retries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">simplification_levels</span><span class="o">=</span><span class="n">simplification_levels</span><span class="p">)</span></div>



<div class="viewcode-block" id="simplify_var_index">
<a class="viewcode-back" href="../../modules.html#anndict.dict.simplify_var_index">[docs]</a>
<span class="k">def</span> <span class="nf">simplify_var_index</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">new_column_name</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplifies gene names in the index of the AnnData object&#39;s var attribute based on a boolean column,</span>
<span class="sd">    and stores the result in a new column using the map_gene_labels_to_simplified_set().</span>

<span class="sd">    Args:</span>
<span class="sd">    adata (AnnData): The AnnData object containing the data.</span>
<span class="sd">    column (str): The boolean column in adata.var used to select genes for simplification.</span>
<span class="sd">    new_column_name (str): The name of the new column to store the simplified labels.</span>
<span class="sd">    simplification_level (str, optional): Defaults to &#39;&#39;. A qualitative description of how much you want the labels to be simplified. Could be anything, like &#39;extremely&#39;, &#39;barely&#39;, or &#39;compartment-level&#39;.</span>

<span class="sd">    Raises:</span>
<span class="sd">    ValueError: If more than 1000 genes are selected for simplification or if the column is not boolean.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">column</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The column &#39;</span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2">&#39; must be a boolean index column.&quot;</span><span class="p">)</span>

    <span class="c1"># Get the index of the true indices in the boolean column</span>
    <span class="n">selected_genes</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">column</span><span class="p">]]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_genes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot simplify more than 1000 genes at a time.&quot;</span><span class="p">)</span>

    <span class="c1"># Get the mapping of original labels to simplified labels using the provided function</span>
    <span class="n">label_mapping</span> <span class="o">=</span> <span class="n">map_gene_labels_to_simplified_set</span><span class="p">(</span><span class="n">selected_genes</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="n">simplification_level</span><span class="p">)</span>

    <span class="c1"># Apply the mapping to create the new column in the AnnData object</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">label_mapping</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_series</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">label_mapping</span></div>



<div class="viewcode-block" id="simplify_var_index_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.simplify_var_index_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">simplify_var_index_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">new_column_name</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies simplify_var_index to each anndata in an anndict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">simplify_var_index</span><span class="p">,</span> <span class="n">max_retries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="n">column</span><span class="p">,</span> <span class="n">new_column_name</span><span class="o">=</span><span class="n">new_column_name</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="n">simplification_level</span><span class="p">)</span></div>



<div class="viewcode-block" id="ai_annotate_cell_type">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_annotate_cell_type">[docs]</a>
<span class="k">def</span> <span class="nf">ai_annotate_cell_type</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;ai_cell_type&#39;</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate cell types based on the top marker genes for each cluster.</span>

<span class="sd">    This function performs differential expression analysis to identify marker genes for each cluster</span>
<span class="sd">    and applies ai_annotate_cell_type to determine the cell type for each cluster based on the top </span>
<span class="sd">    marker genes. The results are added to the AnnData object and returned as a DataFrame.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata : AnnData</span>
<span class="sd">    groupby : str Column in adata.obs to group by for differential expression analysis.</span>
<span class="sd">    n_top_genes : int The number of top marker genes to consider for each cluster.</span>
<span class="sd">    label_column : str, optional (default: &#39;ai_cell_type&#39;) The name of the new column in adata.obs where the cell type annotations will be stored.</span>

<span class="sd">    Returns:</span>
<span class="sd">    pd.DataFrame A DataFrame with a column for the top marker genes for each cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ai_annotate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">ai_cell_type</span><span class="p">,</span> <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="n">n_top_genes</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="n">label_column</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="n">tissue_of_origin_col</span><span class="p">)</span></div>



<div class="viewcode-block" id="ai_annotate_cell_type_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_annotate_cell_type_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">ai_annotate_cell_type_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;ai_cell_type&#39;</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies ai_annotate_cell_type to each anndata in an anndict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">ai_annotate_cell_type</span><span class="p">,</span> <span class="n">max_retries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="n">n_top_genes</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="n">label_column</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="n">tissue_of_origin_col</span><span class="p">)</span></div>



<div class="viewcode-block" id="ai_annotate_cell_sub_type_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_annotate_cell_sub_type_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">ai_annotate_cell_sub_type_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">cell_type_col</span><span class="p">,</span> <span class="n">sub_cluster_col</span><span class="p">,</span> <span class="n">new_label_col</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate cell subtypes for a dictionary of AnnData objects.</span>

<span class="sd">    This function applies the ai_annotate_cell_sub_type function to each AnnData object</span>
<span class="sd">    in the provided dictionary.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict : dict Dictionary of AnnData objects.</span>
<span class="sd">    cell_type_col : str Column name in adata.obs containing main cell type labels.</span>
<span class="sd">    new_label_col : str Name of the column to store the AI-generated subtype labels.</span>

<span class="sd">    Returns:</span>
<span class="sd">    dict Dictionary of annotated AnnData objects with AI-generated subtype labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">ai_annotate_cell_sub_type</span><span class="p">,</span> <span class="n">max_retries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">cell_type_col</span><span class="o">=</span><span class="n">cell_type_col</span><span class="p">,</span> <span class="n">sub_cluster_col</span><span class="o">=</span><span class="n">sub_cluster_col</span><span class="p">,</span> <span class="n">new_label_col</span><span class="o">=</span><span class="n">new_label_col</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="n">tissue_of_origin_col</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="n">n_top_genes</span><span class="p">)</span>
    <span class="n">annotated_adata_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">label_mappings_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">return</span> <span class="n">annotated_adata_dict</span><span class="p">,</span> <span class="n">label_mappings_dict</span></div>



<div class="viewcode-block" id="ai_annotate_cell_sub_type">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_annotate_cell_sub_type">[docs]</a>
<span class="k">def</span> <span class="nf">ai_annotate_cell_sub_type</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">cell_type_col</span><span class="p">,</span> <span class="n">sub_cluster_col</span><span class="p">,</span> <span class="n">new_label_col</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate cell subtypes using AI.</span>

<span class="sd">    This function performs AI-based annotation of cell subtypes by first grouping cells</span>
<span class="sd">    by their main cell type, then annotating subtypes within each group.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata : AnnData Annotated data matrix.</span>
<span class="sd">    cell_type_col : str Column name in adata.obs containing main cell type labels.</span>
<span class="sd">    sub_cluster_col : str Column name in adata.obs containing sub-cluster information.</span>
<span class="sd">    new_label_col : str Name of the column to store the AI-generated subtype labels.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    tuple A tuple containing:</span>
<span class="sd">    AnnData: Concatenated annotated data with AI-generated subtype labels.</span>
<span class="sd">    dict: Mapping of original labels to AI-generated labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#build adata_dict based on cell_type_col</span>
    <span class="n">adata_dict</span> <span class="o">=</span> <span class="n">build_adata_dict</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">strata_keys</span><span class="o">=</span><span class="n">cell_type_col</span><span class="p">)</span>

    <span class="n">label_mappings</span> <span class="o">=</span> <span class="n">ai_annotate_cell_type_by_comparison_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="n">sub_cluster_col</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="n">n_top_genes</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="n">new_label_col</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="n">tissue_of_origin_col</span><span class="p">,</span> <span class="n">subtype</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">adata</span> <span class="o">=</span> <span class="n">concatenate_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">index_unique</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="c1">#setting index_unique=None avoids index modification</span>

    <span class="k">return</span> <span class="n">adata</span><span class="p">,</span> <span class="n">label_mappings</span></div>



<div class="viewcode-block" id="ai_annotate_cell_type_by_comparison_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_annotate_cell_type_by_comparison_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">ai_annotate_cell_type_by_comparison_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;ai_cell_type_by_comparison&#39;</span><span class="p">,</span> <span class="n">cell_type_of_origin_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies ai_annotate_cell_type_by_comparison to each anndata in an anndict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">ai_annotate_cell_type_by_comparison</span><span class="p">,</span> <span class="n">max_retries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="n">n_top_genes</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="n">label_column</span><span class="p">,</span> <span class="n">cell_type_of_origin_col</span><span class="o">=</span><span class="n">cell_type_of_origin_col</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="n">tissue_of_origin_col</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="ai_annotate_cell_type_by_comparison">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_annotate_cell_type_by_comparison">[docs]</a>
<span class="k">def</span> <span class="nf">ai_annotate_cell_type_by_comparison</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;ai_cell_type_by_comparison&#39;</span><span class="p">,</span> <span class="n">cell_type_of_origin_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">adt_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate cell types by comparison using AI.</span>

<span class="sd">    This function wraps the ai_annotate function to perform cell type annotation</span>
<span class="sd">    based on comparison of gene expression profiles.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata : AnnData Annotated data matrix.</span>
<span class="sd">    groupby : str Column name in adata.obs for grouping cells.</span>
<span class="sd">    n_top_genes : int Number of top genes to consider for annotation.</span>
<span class="sd">    label_column : str, optional Name of the column to store the AI-generated cell type labels (default: &#39;ai_cell_type_by_comparison&#39;).</span>

<span class="sd">    Returns:</span>
<span class="sd">    AnnData Annotated data with AI-generated cell type labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># print(f&quot;number of unique categories: {len(adata.obs[groupby].unique())}&quot;)</span>
    <span class="c1"># if tissue_of_origin_col:</span>
    <span class="c1">#     tissue = adata.obs[tissue_of_origin_col].unique()</span>
    <span class="c1">#     if len(tissue == 1):</span>
    <span class="c1">#         tissue = tissue[0]</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         raise ValueError(f&quot;Multiple tissues of_origin found in adata.obs[{tissue_of_origin_col}]. Currently must have only one tissue of origin per cell type. Pick a different tissue of origin column or set tissue_of_origin_col=None&quot;)</span>
    <span class="c1"># else:</span>
    <span class="c1">#     tissue = None</span>
    <span class="k">return</span> <span class="n">ai_annotate_by_comparison</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">ai_cell_types_by_comparison</span><span class="p">,</span> <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="n">n_top_genes</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="n">label_column</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="n">adt_key</span><span class="p">,</span> <span class="n">cell_type_of_origin_col</span><span class="o">=</span><span class="n">cell_type_of_origin_col</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="n">tissue_of_origin_col</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="ai_annotate_biological_process">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_annotate_biological_process">[docs]</a>
<span class="k">def</span> <span class="nf">ai_annotate_biological_process</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;ai_biological_process&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate biological processes based on the top n marker genes for each cluster.</span>

<span class="sd">    This function performs differential expression analysis to identify marker genes for each cluster</span>
<span class="sd">    and applies a user-defined function to determine the biological processes for each cluster based on the top </span>
<span class="sd">    marker genes. The results are added to the AnnData object and returned as a DataFrame.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata : AnnData</span>
<span class="sd">    groupby : str Column in adata.obs to group by for differential expression analysis.</span>
<span class="sd">    n_top_genes : int The number of top marker genes to consider for each cluster.</span>
<span class="sd">    label_column : str, optional (default: &#39;ai_cell_type&#39;) The name of the new column in adata.obs where the cell type annotations will be stored.</span>

<span class="sd">    Returns:</span>
<span class="sd">    pd.DataFrame A DataFrame with a column for the top marker genes for each cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ai_annotate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">ai_biological_process</span><span class="p">,</span> <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="n">n_top_genes</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="n">label_column</span><span class="p">)</span></div>



<div class="viewcode-block" id="ai_annotate_biological_process_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_annotate_biological_process_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">ai_annotate_biological_process_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;ai_biological_process&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies ai_annotate_biological_process to each anndata in an anndict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">ai_annotate_biological_process</span><span class="p">,</span> <span class="n">max_retries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="n">n_top_genes</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="n">label_column</span><span class="p">)</span></div>



<div class="viewcode-block" id="ai_annotate_by_comparison">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_annotate_by_comparison">[docs]</a>
<span class="k">def</span> <span class="nf">ai_annotate_by_comparison</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="p">,</span> <span class="n">label_column</span><span class="p">,</span> <span class="n">cell_type_of_origin_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate clusters based on the top marker genes for each cluster.</span>

<span class="sd">    This uses marker genes for each cluster and applies func to determine the label for each cluster based on the top n</span>
<span class="sd">    marker genes. The results are added to the AnnData object and returned as a DataFrame.</span>

<span class="sd">    If rank_genes_groups hasn&#39;t been run on the adata, this function will automatically run sc.tl.rank_genes_groups</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata : AnnData</span>
<span class="sd">    groupby : str Column in adata.obs to group by for differential expression analysis.</span>
<span class="sd">    n_top_genes : int The number of top marker genes to consider for each cluster.</span>
<span class="sd">    label_column : str The name of the new column in adata.obs where the annotations will be stored.</span>

<span class="sd">    Returns:</span>
<span class="sd">    pd.DataFrame A DataFrame with a column for the top marker genes for each cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if rank_genes_groups has already been run</span>
    <span class="k">if</span> <span class="s1">&#39;rank_genes_groups&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span> <span class="ow">or</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;rank_genes_groups&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;groupby&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">groupby</span><span class="p">:</span>
        <span class="c1"># Run the differential expression analysis</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">rank_genes_groups</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;t-test&#39;</span><span class="p">)</span>

    <span class="c1"># Initialize a dictionary to store cell type annotations</span>
    <span class="n">cell_type_annotations</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Initialize a list to store the results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Get the rank genes groups result</span>
    <span class="n">rank_genes_groups</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;rank_genes_groups&#39;</span><span class="p">]</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="n">rank_genes_groups</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>  <span class="c1"># List of clusters</span>

    <span class="c1"># Check if tissue_of_origin_col exists in adata.obs</span>
    <span class="k">if</span> <span class="n">tissue_of_origin_col</span> <span class="ow">and</span> <span class="n">tissue_of_origin_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tissue of origin column &#39;</span><span class="si">{</span><span class="n">tissue_of_origin_col</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs, will not consider tissue of origin for cell type annotation.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="n">tissue_of_origin_col</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Check if cell_type_of_origin_col exists in adata.obs</span>
    <span class="k">if</span> <span class="n">cell_type_of_origin_col</span> <span class="ow">and</span> <span class="n">cell_type_of_origin_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type of origin column &#39;</span><span class="si">{</span><span class="n">cell_type_of_origin_col</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs, will not consider cell type of origin for annotation.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="n">cell_type_of_origin_col</span> <span class="o">=</span> <span class="kc">None</span>
    

    <span class="c1"># Get mappings of clusters to tissues and cell types</span>
    <span class="n">cluster_to_tissue</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">cluster_to_cell_type</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">tissue_of_origin_col</span> <span class="ow">or</span> <span class="n">cell_type_of_origin_col</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster</span>
            
            <span class="c1"># Map the cluster to tissues if tissue_of_origin_col is provided</span>
            <span class="k">if</span> <span class="n">tissue_of_origin_col</span><span class="p">:</span>
                <span class="n">cluster_to_tissue</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># Map the cluster to cell types if cell_type_of_origin_col is provided</span>
            <span class="k">if</span> <span class="n">cell_type_of_origin_col</span><span class="p">:</span>
                <span class="n">cluster_to_cell_type</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">cell_type_of_origin_col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>


    <span class="c1"># Create a list of lists for top genes</span>
    <span class="n">top_genes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">rank_genes_groups</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">][</span><span class="n">cluster</span><span class="p">][:</span><span class="n">n_top_genes</span><span class="p">])</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">]</span>

    <span class="c1"># Create a list of tissues for each cluster and add to kwargs if tissue_of_origin_col is provided</span>
    <span class="k">if</span> <span class="n">tissue_of_origin_col</span><span class="p">:</span>
        <span class="n">tissues_per_cluster</span> <span class="o">=</span> <span class="p">[</span><span class="n">cluster_to_tissue</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">]</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tissues&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tissues_per_cluster</span>

    <span class="c1"># Create a list of cell types for each cluster and add to kwargs if cell_type_of_origin_col is provided</span>
    <span class="k">if</span> <span class="n">cell_type_of_origin_col</span><span class="p">:</span>
        <span class="n">cell_types_per_cluster</span> <span class="o">=</span> <span class="p">[</span><span class="n">cluster_to_cell_type</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">]</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cell_types&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_types_per_cluster</span>

    <span class="c1"># Call func with the list of lists</span>
    <span class="n">annotations</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">top_genes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Loop through each cluster and annotation</span>
    <span class="k">for</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">annotations</span><span class="p">):</span>
        <span class="n">cell_type_annotations</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">annotation</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="n">groupby</span><span class="p">:</span> <span class="n">cluster</span><span class="p">,</span>
            <span class="n">label_column</span><span class="p">:</span> <span class="n">annotation</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;top_</span><span class="si">{</span><span class="n">n_top_genes</span><span class="si">}</span><span class="s2">_genes&quot;</span><span class="p">:</span> <span class="n">top_genes</span><span class="p">[</span><span class="n">clusters</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>
        <span class="p">})</span>


    <span class="c1"># Create a new column in .obs for cell type annotations</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">label_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_type_annotations</span><span class="p">)</span>

    <span class="c1">#Convert annotation to categorical dtype</span>
    <span class="n">convert_obs_col_to_category</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">label_column</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>


<div class="viewcode-block" id="ai_annotate">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_annotate">[docs]</a>
<span class="k">def</span> <span class="nf">ai_annotate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="p">,</span> <span class="n">label_column</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate clusters based on the top marker genes for each cluster.</span>

<span class="sd">    This uses marker genes for each cluster and applies func to determine the label for each cluster based on the top n</span>
<span class="sd">    marker genes. The results are added to the AnnData object and returned as a DataFrame.</span>

<span class="sd">    If rank_genes_groups hasn&#39;t been run on the adata, this function will automatically run sc.tl.rank_genes_groups</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata : AnnData</span>
<span class="sd">    groupby : str Column in adata.obs to group by for differential expression analysis.</span>
<span class="sd">    n_top_genes : int The number of top marker genes to consider for each cluster.</span>
<span class="sd">    label_column : str The name of the new column in adata.obs where the annotations will be stored.</span>

<span class="sd">    Returns:</span>
<span class="sd">    pd.DataFrame A DataFrame with a column for the top marker genes for each cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure the groupby column is categorical</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]):</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
    
    <span class="c1"># Get the number of categories in the groupby column</span>
    <span class="n">n_categories</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>
    
    <span class="c1"># Warn if there are more than 50 categories</span>
    <span class="k">if</span> <span class="n">n_categories</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The &#39;</span><span class="si">{</span><span class="n">groupby</span><span class="si">}</span><span class="s2">&#39; column has </span><span class="si">{</span><span class="n">n_categories</span><span class="si">}</span><span class="s2"> groups, which may result in slow runtimes. Ensure that </span><span class="si">{</span><span class="n">groupby</span><span class="si">}</span><span class="s2"> is not continuous data.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>

    <span class="c1"># Check if rank_genes_groups has already been run</span>
    <span class="k">if</span> <span class="s1">&#39;rank_genes_groups&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span> <span class="ow">or</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;rank_genes_groups&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;groupby&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">groupby</span><span class="p">:</span>
        <span class="c1"># Run the differential expression analysis</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;rerunning diffexp analysis because not found in adata.uns for adata.obs[&#39;</span><span class="si">{</span><span class="n">groupby</span><span class="si">}</span><span class="s2">&#39;]. (run before annotating to avoid this)&quot;</span><span class="p">)</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">rank_genes_groups</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;t-test&#39;</span><span class="p">)</span>

    <span class="c1"># Get the rank genes groups result</span>
    <span class="n">rank_genes_groups</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;rank_genes_groups&#39;</span><span class="p">]</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="n">rank_genes_groups</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>

    <span class="c1"># Check if tissue_of_origin_col exists in adata.obs</span>
    <span class="k">if</span> <span class="n">tissue_of_origin_col</span> <span class="ow">and</span> <span class="n">tissue_of_origin_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tissue of origin column &#39;</span><span class="si">{</span><span class="n">tissue_of_origin_col</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs, will not consider tissue of origin for cell type annotation.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="n">tissue_of_origin_col</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># Get mapping of cluster to tissue if tissue_of_origin_col is provided</span>
    <span class="n">cluster_to_tissue</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">tissue_of_origin_col</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">tissue</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">tissue_of_origin_col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tissue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tissue</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tissue</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tissue</span> <span class="o">=</span> <span class="n">tissue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cluster_to_tissue</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">tissue</span>

    <span class="c1"># Initialize a dictionary to store cell type annotations</span>
    <span class="n">cell_type_annotations</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Initialize a list to store the results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="c1"># Loop through each cluster and get the top n marker genes, then get cell type based on these marker genes</span>
    <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
        <span class="c1"># Add tissue to kwargs if tissue_of_origin_col is provided</span>
        <span class="k">if</span> <span class="n">tissue_of_origin_col</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tissue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_to_tissue</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span>

        <span class="c1">#Get top n genes</span>
        <span class="n">top_genes</span> <span class="o">=</span> <span class="n">rank_genes_groups</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">][</span><span class="n">cluster</span><span class="p">][:</span><span class="n">n_top_genes</span><span class="p">]</span>

        <span class="c1">#Get annotation via func</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">top_genes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">cell_type_annotations</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">annotation</span>

        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="n">groupby</span><span class="p">:</span> <span class="n">cluster</span><span class="p">,</span>
            <span class="n">label_column</span><span class="p">:</span> <span class="n">annotation</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;top_</span><span class="si">{</span><span class="n">n_top_genes</span><span class="si">}</span><span class="s2">_genes&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">top_genes</span><span class="p">)</span>
        <span class="p">})</span>

    <span class="c1"># Create a new column in .obs for cell type annotations</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">label_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_type_annotations</span><span class="p">)</span>

    <span class="c1">#Convert annotation to categorical dtype</span>
    <span class="n">convert_obs_col_to_category</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">label_column</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>



<div class="viewcode-block" id="ai_unify_labels">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_unify_labels">[docs]</a>
<span class="k">def</span> <span class="nf">ai_unify_labels</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">label_columns</span><span class="p">,</span> <span class="n">new_label_column</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="s1">&#39;unified, typo-fixed&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unifies cell type labels across multiple AnnData objects by mapping them to a simplified, unified set of labels.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict (dict): Dictionary where keys are identifiers and values are AnnData objects.</span>
<span class="sd">    label_columns (dict): Dictionary where keys should be the same as the keys of adata_dict and values are the column names in .obs containing the original labels.</span>
<span class="sd">    new_label_column (str): Name of the new column to be created in .obs for storing the harmonized labels.</span>

<span class="sd">    Returns:</span>
<span class="sd">    dict: A mapping dictionary where the keys are the original labels and the values are the unified labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#todo: use adata_dict_fapply instead of loops</span>
    <span class="k">def</span> <span class="nf">get_unique_labels_from_obs_column</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">label_column</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">label_column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">apply_mapping_to_adata</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">mapping_dict</span><span class="p">,</span> <span class="n">original_column</span><span class="p">,</span> <span class="n">new_column</span><span class="p">,</span> <span class="n">adt_key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">original_column</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span>

    <span class="c1"># Step 1: Aggregate all labels</span>
    <span class="c1"># aggregated_labels = adata_dict_fapply_return(adata_dict, get_unique_labels_from_obs_column, )</span>
    <span class="n">aggregated_labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">adata_dict</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">get_unique_labels_from_obs_column</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">label_columns</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="n">aggregated_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">unique_labels_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">aggregated_labels</span><span class="p">))</span>

    <span class="c1"># Step 2: Get the mapping dictionary</span>
    <span class="n">mapping_dict</span> <span class="o">=</span> <span class="n">map_cell_type_labels_to_simplified_set</span><span class="p">(</span><span class="n">unique_labels_list</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="n">simplification_level</span><span class="p">)</span>

    <span class="c1"># Step 3: Apply the mapping to each anndata in adata_dict</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">adata_dict</span><span class="p">:</span>
        <span class="n">apply_mapping_to_adata</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">mapping_dict</span><span class="p">,</span> <span class="n">label_columns</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">new_label_column</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mapping_dict</span></div>


<span class="c1">#the following functions also unify labels but serve a different purpose than ai_unify_labels.</span>
<span class="c1">#ai_unify_labels is meant to unify labels across multiple adata</span>
<span class="c1">#the following set of ensure_label functions are meant to operate within a single adata</span>
<span class="c1">#and do not communicate across multiple adata in a dict</span>

<div class="viewcode-block" id="ensure_label_consistency_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ensure_label_consistency_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">ensure_label_consistency_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="s1">&#39;unified, typo-fixed&#39;</span><span class="p">,</span> <span class="n">new_col_prefix</span><span class="o">=</span><span class="s1">&#39;consistent&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply label consistency across multiple AnnData objects in a dictionary.</span>

<span class="sd">    This function applies ensure_label_consistency_adata to each AnnData in adata_dict.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    adata_dict : dict Dictionary of AnnData objects.</span>
<span class="sd">    cols : list List of column names in adata.obs for which label consistency is enforced.</span>
<span class="sd">    simplification_level : str, optional Level of label simplification (default is &#39;unified, typo-fixed&#39;).</span>
<span class="sd">    new_col_prefix : str, optional Prefix for the new consistent label columns (default is &#39;consistent&#39;).</span>

<span class="sd">    See ensure_label_consistency_adata for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">ensure_label_consistency_adata</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="n">simplification_level</span><span class="p">,</span> <span class="n">new_col_prefix</span><span class="o">=</span><span class="n">new_col_prefix</span><span class="p">)</span></div>



<div class="viewcode-block" id="ensure_label_consistency_adata">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ensure_label_consistency_adata">[docs]</a>
<span class="k">def</span> <span class="nf">ensure_label_consistency_adata</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="s1">&#39;unified, typo-fixed&#39;</span><span class="p">,</span> <span class="n">new_col_prefix</span><span class="o">=</span><span class="s1">&#39;consistent&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function to ensure label consistency across specified columns in an AnnData object.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    - adata: AnnData object</span>
<span class="sd">    - cols: List of column names in adata.obs to ensure label consistency</span>
<span class="sd">    - simplification_level: Level of simplification for label mapping</span>
<span class="sd">    - new_col_prefix: Prefix to create new columns in adata.obs. Default is &quot;&quot; (overwrites original columns).</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    - Updated adata with consistent labels in adata.obs[new_col_prefix + cols]</span>
<span class="sd">    - label_map: Dictionary mapping original labels to the simplified labels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Step 1: Extract the relevant columns from adata.obs into a DataFrame</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># Step 2: Ensure label consistency using the helper function</span>
    <span class="n">consistent_df</span><span class="p">,</span> <span class="n">label_map</span> <span class="o">=</span> <span class="n">ensure_label_consistency_main</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">simplification_level</span><span class="p">)</span>
    
    <span class="c1"># Step 3: Create new columns in adata.obs with the prefix</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
        <span class="n">new_col_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_col_prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">consistent_df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">label_map</span></div>



<div class="viewcode-block" id="ensure_label_consistency_main">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ensure_label_consistency_main">[docs]</a>
<span class="k">def</span> <span class="nf">ensure_label_consistency_main</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="s1">&#39;unified, typo-fixed&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to ensure label consistency across multiple columns in a DataFrame</span>
<span class="sd">    by mapping labels to a unified and simplified set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Step 1: Normalize all labels in the DataFrame</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">normalize_label</span><span class="p">)</span>
    
    <span class="c1"># Step 2: Create a unified set of unique labels across all columns</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">unique_labels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
    
    <span class="c1"># Step 3: Use the external function to map labels to a simplified set</span>
    <span class="n">unique_labels_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">)</span>
    <span class="n">mapping_dict</span> <span class="o">=</span> <span class="n">map_cell_type_labels_to_simplified_set</span><span class="p">(</span><span class="n">unique_labels_list</span><span class="p">,</span> <span class="n">simplification_level</span><span class="o">=</span><span class="n">simplification_level</span><span class="p">)</span>
    
    <span class="c1"># Step 4: Apply the mapping dictionary to all columns</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">mapping_dict</span></div>



<div class="viewcode-block" id="create_label_df">
<a class="viewcode-back" href="../../modules.html#anndict.dict.create_label_df">[docs]</a>
<span class="k">def</span> <span class="nf">create_label_df</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">cols1</span><span class="p">,</span> <span class="n">cols2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a DataFrame of unique label combinations from the specified columns in cols1 and cols2,</span>
<span class="sd">    only including combinations that exist in adata.obs.</span>
<span class="sd">    Parameters:</span>
<span class="sd">    adata: AnnData object containing the data.</span>
<span class="sd">    cols1: List of columns to compare against cols2.</span>
<span class="sd">    cols2: List of columns to compare with cols1.</span>
<span class="sd">    Returns:</span>
<span class="sd">    pd.DataFrame: DataFrame containing unique combinations of the specified columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Combine all columns</span>
    <span class="n">all_cols</span> <span class="o">=</span> <span class="n">cols1</span> <span class="o">+</span> <span class="n">cols2</span>
    
    <span class="c1"># Get unique combinations that exist in adata.obs</span>
    <span class="n">unique_combinations</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">all_cols</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
    
    <span class="c1"># Melt the DataFrame to get all combinations in two columns</span>
    <span class="n">melted_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">unique_combinations</span><span class="p">,</span> 
                        <span class="n">id_vars</span><span class="o">=</span><span class="n">cols1</span><span class="p">,</span> 
                        <span class="n">value_vars</span><span class="o">=</span><span class="n">cols2</span><span class="p">,</span> 
                        <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;col2_name&#39;</span><span class="p">,</span> 
                        <span class="n">value_name</span><span class="o">=</span><span class="s1">&#39;col2&#39;</span><span class="p">)</span>
    
    <span class="c1"># Melt again to get col1 in a single column</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">melted_df</span><span class="p">,</span>
                        <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;col2_name&#39;</span><span class="p">,</span> <span class="s1">&#39;col2&#39;</span><span class="p">],</span>
                        <span class="n">value_vars</span><span class="o">=</span><span class="n">cols1</span><span class="p">,</span>
                        <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;col1_name&#39;</span><span class="p">,</span>
                        <span class="n">value_name</span><span class="o">=</span><span class="s1">&#39;col1&#39;</span><span class="p">)</span>
    
    <span class="c1"># Keep only the relevant columns and drop duplicates</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="p">[[</span><span class="s1">&#39;col1&#39;</span><span class="p">,</span> <span class="s1">&#39;col2&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">result_df</span></div>



<div class="viewcode-block" id="ai_compare_cell_type_labels_pairwise">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_compare_cell_type_labels_pairwise">[docs]</a>
<span class="k">def</span> <span class="nf">ai_compare_cell_type_labels_pairwise</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">cols1</span><span class="p">,</span> <span class="n">cols2</span><span class="p">,</span> <span class="n">new_col_prefix</span><span class="o">=</span><span class="s1">&#39;agreement&#39;</span><span class="p">,</span> <span class="n">comparison_level</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare cell type labels by finding unique combinations between labels in cols1 and cols2,</span>
<span class="sd">    applying the comparison, and mapping the results back to adata.obs.</span>
<span class="sd">    Parameters:</span>
<span class="sd">    adata: AnnData object containing the data.</span>
<span class="sd">    cols1: List of columns to compare against cols2.</span>
<span class="sd">    cols2: List of columns to compare with cols1.</span>
<span class="sd">    new_col_prefix: The base name for the new comparison result columns.</span>
<span class="sd">    comparison_level: &#39;binary&#39; or &#39;categorical&#39;, determines which comparison function to use.</span>
<span class="sd">    Returns:</span>
<span class="sd">    dict: Dictionary with keys as tuples of (col1, col2) and values as DataFrames with the comparison results.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if comparison_level is valid</span>
    <span class="k">if</span> <span class="n">comparison_level</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;binary&#39;</span><span class="p">,</span> <span class="s1">&#39;categorical&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;comparison_level must be either &#39;binary&#39; or &#39;categorical&#39;.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Call create_label_df to generate the label combinations DataFrame</span>
    <span class="n">label_combinations</span> <span class="o">=</span> <span class="n">create_label_df</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">cols1</span><span class="p">,</span> <span class="n">cols2</span><span class="p">)</span>

    <span class="c1"># Define the comparison and cleaning functions based on the level</span>
    <span class="k">if</span> <span class="n">comparison_level</span> <span class="o">==</span> <span class="s1">&#39;binary&#39;</span><span class="p">:</span>
        <span class="n">comparison_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">ai_compare_cell_types_binary</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;col1&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;col2&#39;</span><span class="p">])</span>
        <span class="n">cleaning_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;yes&#39;</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;no&#39;</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">comparison_level</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
        <span class="n">comparison_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">ai_compare_cell_types_categorical</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;col1&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;col2&#39;</span><span class="p">])</span>
        <span class="n">cleaning_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;no match&#39;</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;partial match&#39;</span> <span class="k">else</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;perfect match&#39;</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="c1"># Convert the label_combinations DataFrame into a list of dictionaries for parallel processing</span>
    <span class="n">label_records</span> <span class="o">=</span> <span class="n">label_combinations</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="s1">&#39;records&#39;</span><span class="p">)</span>

    <span class="c1"># Use ThreadPoolExecutor to apply the comparison function using threads for API calls</span>
    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="c1"># Submit comparison tasks in parallel</span>
        <span class="n">future_to_row</span> <span class="o">=</span> <span class="p">{</span><span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">comparison_func</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span> <span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">label_records</span><span class="p">}</span>

        <span class="c1"># Process the results as they are completed</span>
        <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">future_to_row</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">future_to_row</span><span class="p">[</span><span class="n">future</span><span class="p">]</span>
            <span class="n">row</span><span class="p">[</span><span class="s1">&#39;raw_agreement&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

    <span class="c1"># Re-create the DataFrame from the processed records</span>
    <span class="n">label_combinations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">label_records</span><span class="p">)</span>

    <span class="c1"># Apply the cleaning function to the &#39;agreement&#39; column</span>
    <span class="n">label_combinations</span><span class="p">[</span><span class="s1">&#39;agreement&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label_combinations</span><span class="p">[</span><span class="s1">&#39;raw_agreement&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">cleaning_func</span><span class="p">)</span>

    <span class="c1"># Initialize a dictionary to store results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># Iterate over each pair of cols1 and cols2 and map the comparison results back</span>
    <span class="k">for</span> <span class="n">col1</span> <span class="ow">in</span> <span class="n">cols1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">col2</span> <span class="ow">in</span> <span class="n">cols2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col1</span> <span class="o">==</span> <span class="n">col2</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Define the new column name in adata.obs for this comparison</span>
            <span class="n">new_col_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_col_prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">col1</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">col2</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="c1"># Prepare a temporary DataFrame from adata.obs</span>
            <span class="n">temp_obs</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[[</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">temp_obs</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Reset index to preserve cell indices</span>
            <span class="n">temp_obs</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;col1_label&#39;</span><span class="p">,</span> <span class="s1">&#39;col2_label&#39;</span><span class="p">]</span>

            <span class="c1"># Merge temp_obs with label_combinations on the label columns</span>
            <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">temp_obs</span><span class="p">,</span>
                <span class="n">label_combinations</span><span class="p">[[</span><span class="s1">&#39;col1&#39;</span><span class="p">,</span> <span class="s1">&#39;col2&#39;</span><span class="p">,</span> <span class="s1">&#39;agreement&#39;</span><span class="p">]],</span>
                <span class="n">left_on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;col1_label&#39;</span><span class="p">,</span> <span class="s1">&#39;col2_label&#39;</span><span class="p">],</span>
                <span class="n">right_on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;col1&#39;</span><span class="p">,</span> <span class="s1">&#39;col2&#39;</span><span class="p">],</span>
                <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span>
            <span class="p">)</span>

            <span class="c1"># Assign the &#39;agreement&#39; values back to adata.obs</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;agreement&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

            <span class="c1"># Store the relevant portion of label_combinations in the results dictionary</span>
            <span class="n">results</span><span class="p">[(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">label_combinations</span><span class="p">[</span>
                <span class="n">label_combinations</span><span class="p">[</span><span class="s1">&#39;col1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">col1</span><span class="p">])</span> <span class="o">&amp;</span>
                <span class="n">label_combinations</span><span class="p">[</span><span class="s1">&#39;col2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">col2</span><span class="p">])</span>
            <span class="p">]</span>

    <span class="k">return</span> <span class="n">results</span></div>



<div class="viewcode-block" id="ai_compare_cell_type_labels_pairwise_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.ai_compare_cell_type_labels_pairwise_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">ai_compare_cell_type_labels_pairwise_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">cols1</span><span class="p">,</span> <span class="n">cols2</span><span class="p">,</span> <span class="n">new_col_prefix</span><span class="o">=</span><span class="s1">&#39;agreement&#39;</span><span class="p">,</span> <span class="n">comparison_level</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies ai_compare_cell_type_labels_pairwise to each anndata in an anndict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">ai_compare_cell_type_labels_pairwise</span><span class="p">,</span> <span class="n">max_retries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">cols1</span><span class="o">=</span><span class="n">cols1</span><span class="p">,</span> <span class="n">cols2</span><span class="o">=</span><span class="n">cols2</span><span class="p">,</span> <span class="n">new_col_prefix</span><span class="o">=</span><span class="n">new_col_prefix</span><span class="p">,</span> <span class="n">comparison_level</span><span class="o">=</span><span class="n">comparison_level</span><span class="p">)</span></div>



<div class="viewcode-block" id="plot_sankey_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.plot_sankey_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">plot_sankey_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies plot_sankey to each anndata in an anndict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">adata_dict_fapply_return</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">plot_sankey</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span></div>



<div class="viewcode-block" id="save_sankey_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.save_sankey_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">save_sankey_adata_dict</span><span class="p">(</span><span class="n">plot_dict</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves each sankey plot in a dictionary (i.e. the return value of plot_sankey_adata_dict)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">plot_dict</span><span class="p">,</span> <span class="n">save_sankey</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_grouped_average_adata_dict">
<a class="viewcode-back" href="../../modules.html#anndict.dict.plot_grouped_average_adata_dict">[docs]</a>
<span class="k">def</span> <span class="nf">plot_grouped_average_adata_dict</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">label_value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    plots the grouped average of a value for each group of a label. label_value must be a dictionary of dictionaries. For example, if adata_dict has two anndata with keys &#39;ad1&#39; and &#39;ad2&#39;, then setting label_value = {&#39;ad1&#39;:{&#39;cell_type&#39;:&#39;pct_counts_mt&#39;}, &#39;ad2&#39;:{&#39;cell_type&#39;:&#39;pct_counts_mt&#39;}} would plot the average of pct_counts_mt for each cell type in the anndata on separate plots for each anndata in adata_dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata_dict_fapply</span><span class="p">(</span><span class="n">adata_dict</span><span class="p">,</span> <span class="n">plot_grouped_average</span><span class="p">,</span> <span class="n">label_value</span><span class="o">=</span><span class="n">label_value</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, ggit12.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>